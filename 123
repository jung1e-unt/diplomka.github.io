<script>
window.exportExcel = async function(table) {
  showExportModal();
  try {
    const p = collectFilterParams();
    if (table) p.set('table', table);

    const sep = exportBaseUrl.includes('?') ? '&' : '?';
    const url = `${exportBaseUrl}${sep}${p.toString()}`;

    const resp = await fetch(url);
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);

    const cd = resp.headers.get('Content-Disposition') || '';
    const m  = cd.match(/filename\*=UTF-8''([^;]+)|filename="?([^\";]+)"?/i);
    const raw = m ? (m[1] || m[2]) : null;

    const fileName = raw
      ? decodeURIComponent(raw)
      : `${(table || 'export')}_${formatNowForFile()}.xlsx`;

    const buffer = await resp.arrayBuffer();

    const wb = XLSX.read(buffer, {
      type: 'array',
      cellDates: false
    });

    wb.SheetNames.forEach(sheetName => {
      const ws = wb.Sheets[sheetName];
      if (!ws['!ref']) return;

      // ---------- Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° ÑÑ‡ÐµÐµÐº ----------
      Object.keys(ws).forEach(addr => {
        if (addr[0] === '!') return;

        const c = ws[addr];
        if (!c || c.t !== 'n' || typeof c.v !== 'number') return;

        const abs = Math.abs(c.v);
        const frac = abs % 1;

        // ðŸ•’ Ð’Ð Ð•ÐœÐ¯ (Ð²ÐºÐ»ÑŽÑ‡Ð°Ñ Ð¾Ñ‚Ñ€Ð¸Ñ†Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ñ)
        if (frac > 0 && abs < 1.5) {
          const totalMinutes = Math.round(frac * 24 * 60);
          const h = Math.floor(totalMinutes / 60) % 24;
          const m = totalMinutes % 60;

          c.t = 's';
          c.v = `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}`;
          delete c.z;
          return;
        }

        // ðŸ“… Ð”ÐÐ¢Ð + Ð’Ð Ð•ÐœÐ¯ < 1900 â†’ Ñ‚ÐµÐºÑÑ‚
        const d = XLSX.SSF.parse_date_code(c.v);
        if (!d) return;

        const jsDate = new Date(
          d.y, d.m - 1, d.d,
          d.H || 0, d.M || 0, d.S || 0
        );

        if (jsDate < new Date(1900, 0, 1)) {
          c.t = 's';
          c.v = formatDateTime(jsDate);
          delete c.z;
        }
      });

      // ---------- Ð°Ð²Ñ‚Ð¾ÑˆÐ¸Ñ€Ð¸Ð½Ð° ----------
      autoFitColumns(ws);

      // ---------- Ð’ÐšÐ›Ð®Ð§ÐÐ•Ðœ Ð¤Ð˜Ð›Ð¬Ð¢Ð  ----------
      ws['!autofilter'] = { ref: ws['!ref'] };
    });

    const out = XLSX.write(wb, {
      bookType: 'xlsx',
      type: 'array'
    });

    const blob = new Blob([out], {
      type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    });

    download(blob, fileName);

  } catch (e) {
    console.error(e);
    showErrorModal('ÐžÑˆÐ¸Ð±ÐºÐ° ÑÐºÑÐ¿Ð¾Ñ€Ñ‚Ð°: ' + e.message);
  } finally {
    hideExportModal();
  }
};

// ================= HELPERS =================

function formatDateTime(d) {
  const p = n => String(n).padStart(2,'0');
  return `${p(d.getDate())}.${p(d.getMonth()+1)}.${d.getFullYear()} ${p(d.getHours())}:${p(d.getMinutes())}`;
}

function autoFitColumns(ws) {
  const range = XLSX.utils.decode_range(ws['!ref']);
  const cols = [];

  for (let C = range.s.c; C <= range.e.c; C++) {
    let maxLen = 8;
    for (let R = range.s.r; R <= range.e.r; R++) {
      const cell = ws[XLSX.utils.encode_cell({ r: R, c: C })];
      if (!cell || cell.v == null) continue;
      maxLen = Math.max(maxLen, String(cell.v).length);
    }
    cols[C] = { wch: Math.min(maxLen + 2, 40) };
  }
  ws['!cols'] = cols;
}

function download(blob, name) {
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = name;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

function formatNowForFile() {
  const d = new Date();
  const p = n => String(n).padStart(2,'0');
  return `${d.getFullYear()}-${p(d.getMonth()+1)}-${p(d.getDate())}_${p(d.getHours())}-${p(d.getMinutes())}`;
}
</script>
