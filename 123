<script>
window.exportExcel = async function(table) {
  showExportModal();
  try {
    const p = collectFilterParams();
    if (table) p.set('table', table);

    const sep = exportBaseUrl.includes('?') ? '&' : '?';
    const url = `${exportBaseUrl}${sep}${p.toString()}`;

    const resp = await fetch(url);
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);

    const cd = resp.headers.get('Content-Disposition') || '';
    const m  = cd.match(/filename\*=UTF-8''([^;]+)|filename="?([^\";]+)"?/i);
    const raw = m ? (m[1] || m[2]) : null;

    const fileName = raw
      ? decodeURIComponent(raw)
      : `${(table || 'export')}_${formatNowForFile()}.xlsx`;

    const buffer = await resp.arrayBuffer();

    // === ЧИТАЕМ XLSX ===
    const wb = XLSX.read(buffer, {
      type: 'array',
      cellDates: true
    });

    const MIN_EXCEL_DATE = new Date(1900, 0, 1);

    wb.SheetNames.forEach(sheetName => {
      const ws = wb.Sheets[sheetName];

      Object.keys(ws).forEach(addr => {
        if (addr[0] === '!') return;

        const cell = ws[addr];
        if (!cell || cell.v == null) return;

        let jsDate = null;

        // 1️⃣ Настоящая дата
        if (cell.t === 'd' && cell.v instanceof Date) {
          jsDate = cell.v;
        }

        // 2️⃣ Число, но выглядит как дата
        if (!jsDate && cell.t === 'n') {
          const parsed = XLSX.SSF.parse_date_code(cell.v);
          if (parsed && parsed.y && parsed.m && parsed.d) {
            jsDate = new Date(
              parsed.y,
              parsed.m - 1,
              parsed.d,
              parsed.H || 0,
              parsed.M || 0,
              parsed.S || 0
            );
          }
        }

        // ❗ Если это дата и она < 1900 → в ТЕКСТ
        if (jsDate && jsDate < MIN_EXCEL_DATE) {
          cell.t = 's';
          cell.v = formatDateTime(jsDate);
          delete cell.z;
        }
      });
    });

    // === ЗАПИСЫВАЕМ НОВЫЙ XLSX ===
    const out = XLSX.write(wb, {
      bookType: 'xlsx',
      type: 'array'
    });

    const blob = new Blob([out], {
      type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    });

    download(blob, fileName);

  } catch (e) {
    console.error(e);
    showErrorModal('Ошибка экспорта: ' + e.message);
  } finally {
    hideExportModal();
  }
};

// ===== helpers =====

function download(blob, name) {
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = name;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

function formatDateTime(d) {
  const p = n => n.toString().padStart(2, '0');
  return `${p(d.getDate())}.${p(d.getMonth()+1)}.${d.getFullYear()} ${p(d.getHours())}:${p(d.getMinutes())}`;
}

function formatNowForFile() {
  const d = new Date();
  const p = n => n.toString().padStart(2,'0');
  return `${d.getFullYear()}-${p(d.getMonth()+1)}-${p(d.getDate())}_${p(d.getHours())}-${p(d.getMinutes())}`;
}
</script>
