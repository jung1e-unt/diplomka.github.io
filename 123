<script>
window.exportExcel = async function(table) {
  showExportModal();
  try {
    const p = collectFilterParams();
    if (table) p.set('table', table);

    const sep = exportBaseUrl.includes('?') ? '&' : '?';
    const url = `${exportBaseUrl}${sep}${p.toString()}`;

    const resp = await fetch(url);
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);

    const cd = resp.headers.get('Content-Disposition') || '';
    const m  = cd.match(/filename\*=UTF-8''([^;]+)|filename="?([^\";]+)"?/i);
    const raw = m ? (m[1] || m[2]) : null;

    const name = raw
      ? decodeURIComponent(raw)
      : `${(table || 'export')}_${formatNowForFile()}.xlsx`;

    const arrayBuffer = await resp.arrayBuffer();

    // ===== РАЗБОР XLSX =====
    const wb = XLSX.read(arrayBuffer, { type: 'array', cellDates: true });

    const minExcelDate = new Date(1900, 0, 1);

    wb.SheetNames.forEach(sheetName => {
      const ws = wb.Sheets[sheetName];

      Object.keys(ws).forEach(cellAddr => {
        if (cellAddr[0] === '!') return;

        const cell = ws[cellAddr];

        // Если это дата
        if (cell.t === 'd' && cell.v instanceof Date) {
          if (cell.v < minExcelDate) {
            // ❗ Превращаем в ТЕКСТ
            cell.t = 's';
            cell.v = formatDateTime(cell.v);
            delete cell.z;
          }
        }

        // Иногда дата приходит как число
        if (cell.t === 'n' && cell.z && /[dy]/i.test(cell.z)) {
          const d = XLSX.SSF.parse_date_code(cell.v);
          if (d) {
            const jsDate = new Date(d.y, d.m - 1, d.d, d.H, d.M, d.S);
            if (jsDate < minExcelDate) {
              cell.t = 's';
              cell.v = formatDateTime(jsDate);
              delete cell.z;
            }
          }
        }
      });
    });

    // ===== ПЕРЕСБОРКА XLSX =====
    const newWbArray = XLSX.write(wb, {
      bookType: 'xlsx',
      type: 'array'
    });

    const blob = new Blob([newWbArray], {
      type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    });

    downloadBlob(blob, name);

  } catch (err) {
    console.error(err);
    showErrorModal('Ошибка экспорта: ' + err.message);
  } finally {
    hideExportModal();
  }
};

// ===== ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ =====

function downloadBlob(blob, filename) {
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

function formatDateTime(d) {
  const pad = n => n.toString().padStart(2, '0');
  return `${pad(d.getDate())}.${pad(d.getMonth()+1)}.${d.getFullYear()} ` +
         `${pad(d.getHours())}:${pad(d.getMinutes())}`;
}

function formatNowForFile() {
  const d = new Date();
  const pad = n => n.toString().padStart(2,'0');
  return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}_` +
         `${pad(d.getHours())}-${pad(d.getMinutes())}`;
}

(async function init(){
  await renderGroups();
  installHandlers();
  enableFilters(false);
  restoreState();
})();
</script>
