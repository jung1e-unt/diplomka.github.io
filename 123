<script>
window.exportExcel = async function(table) {
  showExportModal();
  try {
    const p = collectFilterParams();
    if (table) p.set('table', table);

    const sep = exportBaseUrl.includes('?') ? '&' : '?';
    const url = `${exportBaseUrl}${sep}${p.toString()}`;

    const resp = await fetch(url);
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);

    const cd = resp.headers.get('Content-Disposition') || '';
    const m  = cd.match(/filename\*=UTF-8''([^;]+)|filename="?([^\";]+)"?/i);
    const raw = m ? (m[1] || m[2]) : null;

    const fileName = raw
      ? decodeURIComponent(raw)
      : `${(table || 'export')}_${formatNowForFile()}.xlsx`;

    const buffer = await resp.arrayBuffer();

    // ===== Ð§Ð˜Ð¢ÐÐ•Ðœ XLSX =====
    const wb = XLSX.read(buffer, {
      type: 'array',
      cellDates: false
    });

    wb.SheetNames.forEach(sheetName => {
      const ws = wb.Sheets[sheetName];
      if (!ws['!ref']) return;

      // ===== ÐžÐ‘Ð ÐÐ‘ÐžÐ¢ÐšÐ Ð¯Ð§Ð•Ð•Ðš =====
      Object.keys(ws).forEach(addr => {
        if (addr[0] === '!') return;

        const c = ws[addr];
        if (!c || c.t !== 'n') return;

        const d = XLSX.SSF.parse_date_code(c.v);
        if (!d) return;

        // ðŸ•’ Ð¢ÐžÐ›Ð¬ÐšÐž Ð’Ð Ð•ÐœÐ¯ (Excel Ñ…Ñ€Ð°Ð½Ð¸Ñ‚ < 1)
        if (c.v < 1) {
          c.t = 's';
          c.v = formatTime(d);
          delete c.z;
          return;
        }

        // ðŸ“… Ð”ÐÐ¢Ð + Ð’Ð Ð•ÐœÐ¯
        const jsDate = new Date(
          d.y, d.m - 1, d.d,
          d.H || 0, d.M || 0, d.S || 0
        );

        // â— Excel < 1900 â†’ Ñ‚ÐµÐºÑÑ‚
        if (jsDate < new Date(1900, 0, 1)) {
          c.t = 's';
          c.v = formatDateTime(jsDate);
          delete c.z;
        }
      });

      // ===== ÐÐ’Ð¢ÐžÐ¨Ð˜Ð Ð˜ÐÐ Ð¡Ð¢ÐžÐ›Ð‘Ð¦ÐžÐ’ =====
      autoFitColumns(ws);
    });

    // ===== Ð¡ÐžÐ¥Ð ÐÐÐ¯Ð•Ðœ XLSX =====
    const out = XLSX.write(wb, {
      bookType: 'xlsx',
      type: 'array'
    });

    const blob = new Blob([out], {
      type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    });

    download(blob, fileName);

  } catch (e) {
    console.error(e);
    showErrorModal('ÐžÑˆÐ¸Ð±ÐºÐ° ÑÐºÑÐ¿Ð¾Ñ€Ñ‚Ð°: ' + e.message);
  } finally {
    hideExportModal();
  }
};

// ================= HELPERS =================

function formatTime(d) {
  const p = n => String(n).padStart(2, '0');
  return `${p(d.H)}:${p(d.M)}`;
}

function formatDateTime(d) {
  const p = n => String(n).padStart(2, '0');
  return `${p(d.getDate())}.${p(d.getMonth()+1)}.${d.getFullYear()} ${p(d.getHours())}:${p(d.getMinutes())}`;
}

function autoFitColumns(ws) {
  const range = XLSX.utils.decode_range(ws['!ref']);
  const cols = [];

  for (let C = range.s.c; C <= range.e.c; C++) {
    let maxLen = 8;

    for (let R = range.s.r; R <= range.e.r; R++) {
      const cell = ws[XLSX.utils.encode_cell({ r: R, c: C })];
      if (!cell || cell.v == null) continue;

      const val = String(cell.v);
      maxLen = Math.max(maxLen, val.length);
    }

    cols[C] = { wch: Math.min(maxLen + 2, 40) };
  }

  ws['!cols'] = cols;
}

function download(blob, name) {
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = name;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

function formatNowForFile() {
  const d = new Date();
  const p = n => String(n).padStart(2,'0');
  return `${d.getFullYear()}-${p(d.getMonth()+1)}-${p(d.getDate())}_${p(d.getHours())}-${p(d.getMinutes())}`;
}
</script>
