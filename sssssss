@page
@model IndexModel
@{
    ViewData["Title"] = "OTCH";
    Layout = null;
}
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="utf-8" />
    <title>@ViewData["Title"]</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
        :root {
            --bg: #f7f7f9;
            --sidebar-bg: #ffffff;
            --content-bg: #ffffff;
            --border: #e0e0e0;
            --text: #222;
            --muted: #666;
            --primary: #2e7d32;
            --primary-hover: #1b5e20;
            --danger: #c62828;
            --table-header: #f4f4f4;
        }

        html, body {
            height: 100%;
            margin: 0;
            background: var(--bg);
            color: var(--text);
            font-family: system-ui, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
            font-size: 16px;
            line-height: 1.4;
            overflow-x: auto;
        }

        .layout {
            display: grid;
            grid-template-columns: 400px 1fr;
            gap: 16px;
            height: 100vh;
        }

        .sidebar {
            background: var(--sidebar-bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px;
            height: 100%;
            overflow-y: auto;
        }

        .content {
            background: var(--content-bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px;
            overflow: auto;
        }

        /* Контейнер таблицы с фиксированной высотой и прокруткой */
        .table-wrap {
            overflow: auto;
            height: 650px;
            border: 1px solid var(--border);
            border-radius: 6px;
            background: #fff;
        }

        table {
            border-collapse: collapse;
            width: 100%;
            min-width: 640px;
        }

        th, td {
            border: 1px solid var(--border);
            padding: 6px 8px;
            vertical-align: top;
            white-space: nowrap;
        }

        thead th {
            background: var(--table-header);
            position: sticky;
            top: 0;
            z-index: 2;
        }

        tr:nth-child(even) td {
            background: #fcfcfc;
        }

        .spinner { color: var(--muted); padding: 12px; }
        .hint { color: var(--muted); }
        .hint-p { color: var(--muted); font-size: 16px; }

        .toolbar { display:flex; gap:8px; align-items:center; margin:8px 0; }

        .btn, .btn-secondary {
            padding: 6px 10px;
            border-radius: 6px;
            cursor: pointer;
            color: #fff;
            background: var(--primary);
            border: none;
        }
        .btn-secondary { background: var(--primary); }
        .btn:disabled { opacity: .6; cursor: not-allowed; }

        /* резета/экспорт модалки */
        .export-modal { display:none; position:fixed; inset:0; background:rgba(0,0,0,.45); z-index:9999; align-items:center; justify-content:center; }
        .export-modal.open { display:flex; }
        .export-modal-box { background:#fff; padding:20px 30px; border-radius:8px; }

        .error-modal { display:none; position:fixed; inset:0; background:rgba(0,0,0,.45); z-index:99999; align-items:center; justify-content:center; }
        .error-modal.open { display:flex; }
        .error-modal-box { background:#fff; padding:20px; border-radius:8px; width:420px; text-align:center; }
        .error-text { color:var(--danger); margin-bottom:12px; }
        .error-close { background:var(--danger); color:#fff; padding:8px 12px; border:none; border-radius:6px; cursor:pointer; }

        /* кнопки выбора таблиц */
        .dropdown { position:relative; }
        .dropdown-toggle { width:100%; padding:8px; border:1px solid var(--border); border-radius:6px; background:#fff; cursor:pointer; text-align:left; }
        .dropdown-menu { position:absolute; left:0; right:0; top:calc(100% + 6px); z-index:1000; background:#fff; border:1px solid var(--border); border-radius:8px; box-shadow:0 6px 16px rgba(0,0,0,.08); display:none; max-height:60vh; overflow:hidden; }
        .dropdown-menu.open { display:block; }
        .dropdown-search { width:100%; padding:6px 8px; margin-bottom:8px; border:1px solid var(--border); border-radius:6px; }

        .group { margin-bottom:8px; border:1px solid var(--border); border-radius:6px; overflow:hidden; }
        .group-header { display:flex; justify-content:space-between; align-items:center; padding:6px 8px; background:#f9f9f9; }
        .group-items { padding:6px 8px; display:grid; gap:4px; }
        .group-item { display:flex; gap:8px; align-items:center; }

        .selected-list { margin-top:12px; display:grid; gap:6px; }
        .selected-btn { padding:6px 8px; border:1px solid var(--border); border-radius:6px; background:#fff; display:flex; align-items:center; justify-content:space-between; cursor:pointer; }
        .selected-remove { color:var(--danger); margin-left:10px; }

    </style>
</head>
<body>
    <div class="layout">
        <aside class="sidebar">
            <h3>Таблицы</h3>
            <div class="dropdown" id="tableDropdown">
                <button class="dropdown-toggle" id="tablePickerToggle">Выбрать таблицы ▾</button>
                <div class="dropdown-menu" id="tablePickerMenu">
                    <div class="dropdown-header">
                        <input id="tableSearch" class="dropdown-search" type="text" placeholder="Поиск по таблицам" />
                    </div>
                    <div class="dropdown-groups" id="tableGroups"></div>
                    <div class="dropdown-actions" style="display:flex; gap:8px; padding:8px; border-top:1px solid var(--border);">
                        <button id="selectAllBtn" type="button">Выбрать все</button>
                        <button id="clearAllBtn" type="button">Сбросить все</button>
                        <button id="applySelectionBtn" class="btn" type="button">Применить</button>
                    </div>
                </div>
            </div>

            <div class="selected-wrap">
                <div class="selected-title">Выбранные таблицы</div>
                <div class="selected-list" id="selectedTables">
                    <div class="hint-p">Пока ничего не выбрано</div>
                </div>
            </div>
        </aside>

        <main class="content">
            <div style="margin-bottom:10px;">
                <h4>Конструктор SQL-запроса</h4>
                <textarea id="sqlQuery" rows="4" style="width:100%;" placeholder="Введите SQL (только SELECT)"></textarea>
                <br>
                <button id="runSqlBtn">Выполнить SQL</button>
            </div>

            <h3>Фильтр</h3>

            <div class="hint" id="filterInfo">
                Сначала выберите таблицу слева. После выбора таблицы станет доступен фильтр по датам.
            </div>

            <div class="toolbar">
                <div style="display:flex; gap:8px; width: 100%; max-width: 540px;">
                    <div style="flex:1;">
                        <label for="startDate">Дата от</label>
                        <input id="startDate" type="date" disabled />
                    </div>
                    <div style="flex:1;">
                        <label for="endDate">Дата до</label>
                        <input id="endDate" type="date" disabled />
                    </div>
                </div>

                <button id="applyFilterBtn" class="btn" disabled>Применить фильтр</button>
                <button id="resetFilterBtn" class="btn-secondary" disabled>Очистить фильтр</button>
            </div>

            <div id="nPartWrap" style="display:none;">
                <label>N_PART:</label>
                <input type="text" id="nPart" placeholder="номер партии" />
            </div>

            <div id="nPlawWrap" style="display:none;">
                <label>N_PLAW:</label>
                <input type="text" id="nPlaw" placeholder="номер плавки" />
            </div>

            <h3>Данные</h3>
            <div id="content">
                <div class="hint">Выберите таблицу слева, затем задайте даты и нажмите «Применить фильтр».</div>
            </div>
        </main>
    </div>

    <!-- модалки -->
    <div id="exportModal" class="export-modal">
        <div class="export-modal-box">Формируется файл, пожалуйста, подождите...</div>
    </div>

    <div id="errorModal" class="error-modal">
        <div class="error-modal-box">
            <div id="errorText" class="error-text">Ошибка</div>
            <button id="errorClose" class="error-close">Закрыть</button>
        </div>
    </div>

    <script>
        // URL-хелперы (рутинные)
        const dataBaseUrl   = '@Url.Page("./Index", "Data")';   // /Index?handler=Data
        const exportBaseUrl = '@Url.Page("./Index", "Export")'; // /Index?handler=Export

        // helper
        const $id = (id) => document.getElementById(id);
        const escapeHtml = (s) => String(s ?? '').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;');
        const formatValue = (v) => v == null ? '' : String(v);

        // --- state for pagination
        let currentTable = null;
        let currentPage = 0;
        const pageSize = 200;   // можно уменьшить/увеличить
        let isLoadingPage = false;
        let reachedEnd = false;
        let lastColumns = [];

        // вспомогательные UI элементы
        const startDateInput = $id('startDate');
        const endDateInput = $id('endDate');
        const applyFilterBtn = $id('applyFilterBtn');
        const resetFilterBtn = $id('resetFilterBtn');

        // --- функции для рендера групп и селектора таблиц (оставил вашу логику)
        const groups = @Html.Raw(System.Text.Json.JsonSerializer.Serialize(Model.GetGroupsForJs ?? new object())); // fallback if not present
        // NOTE: если Model.GetGroupsForJs не существует - ниже мы используем встроенный список JS (самый простой вариант)
        // для совместимости, если сервер не даёт groups, используем клиента (вставьте список вручную если нужно)

        // Если у вас нет Model.GetGroupsForJs, замените код renderGroups на вызов, использующий встроенные группы из вашего первого файла.
        // Для простоты мы сделаем динамический render — но если Model.GetGroupsForJs отсутствует, реализуйте renderGroups вручную.

        // Простая реализация renderGroups (если сервер не передал groups)
        const builtinGroups = (function(){
            return {
                "ALL": @Html.Raw(System.Text.Json.JsonSerializer.Serialize(IndexModel.AllowedTables.ToArray()))
            };
        })();

        async function getTablesMeta() {
            try {
                const res = await fetch('@Url.Page("./Index", "TablesState")');
                if (!res.ok) throw new Error('HTTP ' + res.status);
                return await res.json();
            } catch(err){
                console.warn('Не удалось получить TablesState:', err);
                return null;
            }
        }

        async function renderGroups() {
            const groupsEl = $id('tableGroups');
            const meta = await getTablesMeta();
            let hasDataSet = null;
            let hasPartSet = new Set();
            let hasPlawSet = new Set();

            if (meta && Array.isArray(meta)) {
                hasDataSet = new Set(meta.filter(m=>m.hasData).map(m=>m.table));
                hasPartSet = new Set(meta.filter(m=>m.hasPart).map(m=>m.table));
                hasPlawSet = new Set(meta.filter(m=>m.hasPlaw).map(m=>m.table));
            }

            // попросту положим все разрешённые таблицы в одну группу если нет сложной структуры
            const groupsObj = builtinGroups;

            groupsEl.innerHTML = Object.keys(groupsObj).map(gName => {
                const items = groupsObj[gName].filter(t => !hasDataSet || hasDataSet.has(t));
                if (!items || items.length === 0) return '';
                return `<section class="group" data-name="${gName}">
                    <div class="group-header">
                        <div class="group-title">${gName}</div>
                        <div class="group-actions">
                            <button type="button" class="group-select" data-name="${gName}">Все</button>
                            <button type="button" class="group-clear"  data-name="${gName}">Сброс</button>
                        </div>
                    </div>
                    <div class="group-items">
                        ${items.map(name => `
                            <label class="group-item">
                                <input type="checkbox" data-table="${name}"/>
                                <span>${name}</span>
                            </label>`).join('')}
                    </div>
                </section>`;
            }).join('');
        }

        function enableFilters(enabled){
            if (startDateInput) startDateInput.disabled = !enabled;
            if (endDateInput) endDateInput.disabled = !enabled;
            if (applyFilterBtn) applyFilterBtn.disabled = !enabled;
            if (resetFilterBtn) resetFilterBtn.disabled = !enabled;

            const sqlBox = $id('sqlQuery');
            const runSqlBtn = $id('runSqlBtn');
            if (sqlBox) sqlBox.disabled = !enabled;
            if (runSqlBtn) runSqlBtn.disabled = !enabled;

            syncExtraFilters(currentTable);
        }

        function syncExtraFilters(table){
            // запрос на сервер хранит __tableHasPart/__tableHasPlaw? мы упростим — при инициализации получим TablesState и выставим видимость
            // но для простоты: проверяем полную таблицу meta (getTablesMeta) — уже применено в renderGroups (meta передаётся)
            // здесь оставим заглушку
            const npWrap = $id('nPartWrap'), nlWrap = $id('nPlawWrap');
            if (!table) { if (npWrap) npWrap.style.display = 'none'; if (nlWrap) nlWrap.style.display = 'none'; return; }
            // по простоте включаем оба — если нет колонок в серверной стороне, сервер просто проигнорирует параметры
            if (npWrap) npWrap.style.display = '';
            if (nlWrap) nlWrap.style.display = '';
        }

        // ---------------- pagination core ----------------
        async function loadPage(reset = false) {
            if (!currentTable) return;
            if (isLoadingPage) return;
            if (reachedEnd && !reset) return;

            isLoadingPage = true;
            if (reset) {
                currentPage = 0;
                reachedEnd = false;
            }

            const params = new URLSearchParams();
            params.set('table', currentTable);
            if (startDateInput && startDateInput.value) params.set('startDate', startDateInput.value);
            if (endDateInput && endDateInput.value) params.set('endDate', endDateInput.value);
            const nPart = $id('nPart')?.value || '';
            const nPlaw = $id('nPlaw')?.value || '';
            if (nPart) params.set('nPart', nPart);
            if (nPlaw) params.set('nPlaw', nPlaw);

            params.set('page', String(currentPage));
            params.set('pageSize', String(pageSize));

            const content = $id('content');
            try {
                // show spinner on first page
                if (currentPage === 0) content.innerHTML = `<div class="spinner">Загрузка данных…</div>`;

                const res = await fetch(`${dataBaseUrl}&${params.toString()}`);
                if (!res.ok) {
                    const txt = await res.text();
                    showErrorModal('Ошибка загрузки данных: ' + txt);
                    isLoadingPage = false;
                    return;
                }

                const json = await res.json();
                // ожидаем { columns: [...], rows: [...] } — если сервер возвращает просто массив, адаптируйте
                const columns = Array.isArray(json.columns) ? json.columns : (json.length && json[0] ? Object.keys(json[0]) : []);
                const rows = Array.isArray(json.rows) ? json.rows : (Array.isArray(json) ? json : []);

                if (reset) {
                    // новая таблица — рендерим заголовки и первые строки
                    if (!rows || rows.length === 0) {
                        content.innerHTML = `
                            <h3>${escapeHtml(currentTable)}</h3>
                            <div class="toolbar">
                                <button id="exportBtn" class="btn" onclick="exportExcel('${encodeURIComponent(currentTable)}')">Экспорт в Excel</button>
                            </div>
                            <p class="hint">Нет данных.</p>`;
                        reachedEnd = true;
                        isLoadingPage = false;
                        return;
                    }

                    lastColumns = columns;
                    renderTableAndRows(columns, rows);
                } else {
                    // append rows
                    if (!rows || rows.length === 0) {
                        // пустая страница -> достигли конца
                        reachedEnd = true;
                    } else {
                        appendRows(rows);
                    }
                }

                // если пришло меньше rows чем pageSize — считаем конец
                if (!rows || rows.length < pageSize) reachedEnd = true;

                currentPage++;
            } catch (err) {
                showErrorModal('Ошибка загрузки данных: ' + err.message);
            } finally {
                isLoadingPage = false;
                // отменим spinner при первом рендере уже внутри renderTableAndRows
            }
        }

        function renderTableAndRows(columns, rows) {
            const content = $id('content');
            const header = `<h3>${escapeHtml(currentTable)}</h3>`;
            const toolbar = `<div class="toolbar"><button id="exportBtn" class="btn" onclick="exportExcel('${encodeURIComponent(currentTable)}')">Экспорт в Excel</button></div>`;

            let thead = `<thead><tr>`;
            for (const c of columns) thead += `<th>${escapeHtml(c)}</th>`;
            thead += `</tr></thead>`;

            let tbody = `<tbody id="tableBody">`;
            for (const r of rows) {
                tbody += `<tr>`;
                for (const c of columns) tbody += `<td>${escapeHtml(formatValue(r[c]))}</td>`;
                tbody += `</tr>`;
            }
            tbody += `</tbody>`;

            content.innerHTML = `${header}${toolbar}<div class="table-wrap" id="scrollTable">${'<table>'+thead+tbody+'</table>'}</div>`;

            // после рендера — установим обработчик скролла
            setupScrollHandler();
        }

        function appendRows(rows) {
            const tbody = $id('tableBody');
            if (!tbody) return;
            const cols = lastColumns;
            let html = '';
            for (const r of rows) {
                html += `<tr>`;
                for (const c of cols) html += `<td>${escapeHtml(formatValue(r[c]))}</td>`;
                html += `</tr>`;
            }
            tbody.insertAdjacentHTML('beforeend', html);
        }

        function clearTable() {
            $id('content').innerHTML = `<div class="hint">Загрузка...</div>`;
        }

        function setupScrollHandler() {
            const wrap = $id('scrollTable');
            if (!wrap) return;

            // удаляем предыдущий обработчик, если был
            wrap.removeEventListener('__infinite__', () => {});
            // добавим scroll listener
            wrap.addEventListener('scroll', onScrollLoad);
        }

        function onScrollLoad(e) {
            const wrap = e.currentTarget;
            if (!wrap || isLoadingPage || reachedEnd) return;
            const bottom = wrap.scrollTop + wrap.clientHeight;
            const full = wrap.scrollHeight;

            // если до конца осталось менее 200px — загрузить следующую страницу
            if (bottom >= full - 200) {
                loadPage(false);
            }
        }

        // export helper (вызов вашего хендлера Export — он отдаёт весь файл)
        async function exportExcel(tableEncoded) {
            const table = decodeURIComponent(tableEncoded);
            const params = new URLSearchParams();
            params.set('table', table);
            if (startDateInput && startDateInput.value) params.set('startDate', startDateInput.value);
            if (endDateInput && endDateInput.value) params.set('endDate', endDateInput.value);
            const nPart = $id('nPart')?.value || '';
            const nPlaw = $id('nPlaw')?.value || '';
            if (nPart) params.set('nPart', nPart);
            if (nPlaw) params.set('nPlaw', nPlaw);

            try {
                $id('exportModal').classList.add('open');
                const res = await fetch('@Url.Page("./Index", "Export")' + '&' + params.toString());
                if (!res.ok) {
                    const txt = await res.text();
                    showErrorModal('Ошибка экспорта: ' + txt);
                    return;
                }
                const cd = res.headers.get('Content-Disposition') || '';
                const m = cd.match(/filename\*=UTF-8''([^;]+)|filename="?([^\";]+)?"?/i);
                const raw = m ? (m[1] || m[2]) : null;
                const name = raw ? decodeURIComponent(raw) : `${table}_${(new Date()).toISOString().slice(0,10)}.xlsx`;
                const blob = await res.blob();
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = name;
                document.body.appendChild(a);
                a.click();
                a.remove();
                URL.revokeObjectURL(url);
            } catch (err) {
                showErrorModal('Ошибка экспорта: ' + err.message);
            } finally {
                $id('exportModal').classList.remove('open');
            }
        }

        // error modal
        function showErrorModal(msg) {
            $id('errorText').textContent = msg;
            $id('errorModal').classList.add('open');
        }
        $id('errorClose').addEventListener('click', ()=> $id('errorModal').classList.remove('open'));

        // ---------- events: selection, filters, sql ----------
        function renderSelectedButtons(names){
            const box = $id('selectedTables');
            if(!names || names.length===0){
                box.innerHTML = '<div class="hint-p">Пока ничего не выбрано</div>';
                currentTable = null;
                enableFilters(false);
                $id('content').innerHTML = '<div class="hint">Выберите таблицу слева.</div>';
                return;
            }
            names.sort((a,b)=>a.localeCompare(b,'ru'));
            box.innerHTML = names.map(name=>`
                <div class="selected-btn" data-table="${name}">
                    <span>${name}</span>
                    <span class="selected-remove" data-remove="${name}">✕</span>
                </div>
            `).join('');

            box.querySelectorAll('.selected-btn').forEach(btn=>{
                btn.addEventListener('click', e=>{
                    const rm = e.target.closest('[data-remove]');
                    if(rm){
                        const removed = rm.dataset.remove;
                        const rest = names.filter(n => n !== removed);
                        renderSelectedButtons(rest);
                        const checkbox = document.querySelector(`input[data-table="${removed}"]`);
                        if (checkbox) checkbox.checked = false;
                        if (currentTable === removed) {
                            currentTable = null;
                            enableFilters(false);
                            $id('content').innerHTML = '<div class="hint">Выберите таблицу слева.</div>';
                        }
                        return;
                    }
                    // при клике — делаем именно эту таблицу активной
                    currentTable = btn.dataset.table;
                    currentPage = 0;
                    reachedEnd = false;
                    lastColumns = [];
                    enableFilters(true);
                    loadPage(true); // первый запрос
                });
            });
        }

        function installHandlers(){
            const toggle   = $id('tablePickerToggle');
            const menu     = $id('tablePickerMenu');
            const search   = $id('tableSearch');
            const groupsEl = $id('tableGroups');

            if (toggle) {
                toggle.addEventListener('click', ()=>menu.classList.toggle('open'));
                document.addEventListener('click', e=>{
                    if(!menu.contains(e.target) && !toggle.contains(e.target)) menu.classList.remove('open');
                });
            }

            if (search) {
                search.addEventListener('input', ()=>{
                    const q = search.value.toLowerCase();
                    for(const item of groupsEl.querySelectorAll('.group-item')){
                        item.style.display = item.textContent.toLowerCase().includes(q)?'':'none';
                    }
                });
            }

            groupsEl.addEventListener('click', e=>{
                const btn = e.target.closest('button.group-select,button.group-clear');
                if(!btn) return;
                const groupName = btn.dataset.name;
                const section = groupsEl.querySelector(`.group[data-name="${groupName}"]`);
                const check = btn.classList.contains('group-select');
                for(const cb of section.querySelectorAll('input[type="checkbox"]')) cb.checked = check;
            });

            $id('selectAllBtn').addEventListener('click', ()=>{
                for(const cb of groupsEl.querySelectorAll('input[type="checkbox"]')) cb.checked = true;
            });
            $id('clearAllBtn').addEventListener('click', ()=>{
                for(const cb of groupsEl.querySelectorAll('input[type="checkbox"]')) cb.checked = false;
            });

            $id('applySelectionBtn').addEventListener('click', ()=>{
                const selected = Array.from(groupsEl.querySelectorAll('input[type="checkbox"]:checked')).map(cb => cb.dataset.table);
                renderSelectedButtons(selected);
                menu.classList.remove('open');
            });

            applyFilterBtn.addEventListener('click', ()=>{
                if(!currentTable){ showErrorModal('Сначала выберите таблицу слева.'); return; }
                // при применении фильтра — перезагружаем с нуля
                currentPage = 0;
                reachedEnd = false;
                loadPage(true);
            });

            resetFilterBtn.addEventListener('click', ()=>{
                startDateInput.value='';
                endDateInput.value='';
                $id('nPart').value='';
                $id('nPlaw').value='';
                if (currentTable) {
                    currentPage = 0;
                    reachedEnd = false;
                    loadPage(true);
                } else enableFilters(false);
            });

            // SQL execution
            $id('runSqlBtn').addEventListener('click', async ()=>{
                const sql = ($id('sqlQuery').value || '').trim();
                if (!sql){ showErrorModal('Введите SQL-запрос!'); return; }
                if (!sql.toUpperCase().startsWith('SELECT')){ showErrorModal('Разрешены только SELECT-запросы.'); return; }
                if (!currentTable){ showErrorModal('Сначала выберите таблицу слева.'); return; }

                const content = $id('content');
                content.innerHTML = `<div class="spinner">Выполнение SQL-запроса…</div>`;

                try {
                    const url = '@Url.Page("./Index", "RunSql")' + `&sql=${encodeURIComponent(sql)}&currentTable=${encodeURIComponent(currentTable)}`;
                    const res = await fetch(url);
                    if (!res.ok){ const txt = await res.text(); showErrorModal('Ошибка выполнения SQL: ' + txt); return; }
                    const data = await res.json();
                    if (!Array.isArray(data) || data.length === 0) {
                        content.innerHTML = `
                            <h3>Результат SQL</h3>
                            <div class="toolbar"><button id="exportBtn" class="btn" disabled>Экспорт в Excel</button></div>
                            <p class="hint">Нет данных.</p>`;
                        return;
                    }
                    const columns = Object.keys(data[0]);
                    lastColumns = columns;
                    // отрисуем таблицу с результатом (без пагинации, т.к. это SQL)
                    renderTableAndRows(columns, data);
                    // экспорт для SQL можно реализовать через ExportSql (у вас есть OnGetExportSql)
                    document.getElementById('exportBtn').onclick = function(){ exportSql(sql); };
                } catch (err) {
                    showErrorModal('Ошибка выполнения SQL: ' + err.message);
                }
            });
        }

        async function exportSql(sql) {
            try {
                $id('exportModal').classList.add('open');
                const url = '@Url.Page("./Index", "ExportSql")' + `&sql=${encodeURIComponent(sql)}`;
                const res = await fetch(url);
                if (!res.ok) { const txt = await res.text(); showErrorModal('Ошибка экспорта SQL: ' + txt); return; }
                const cd = res.headers.get('Content-Disposition') || '';
                const m = cd.match(/filename\*=UTF-8''([^;]+)|filename="?([^\";]+)?"?/i);
                const raw = m ? (m[1] || m[2]) : null;
                const name = raw ? decodeURIComponent(raw) : `sql_${(new Date()).toISOString().slice(0,10)}.xlsx`;
                const blob = await res.blob();
                const urlBlob = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = urlBlob; a.download = name; document.body.appendChild(a); a.click(); a.remove();
                URL.revokeObjectURL(urlBlob);
            } catch (err) {
                showErrorModal('Ошибка экспорта SQL: ' + err.message);
            } finally {
                $id('exportModal').classList.remove('open');
            }
        }

        // init
        (async function init(){
            await renderGroups();
            installHandlers();
            enableFilters(false);
            renderSelectedButtons([]);
            // Note: если хотите — можно сразу загрузить первую таблицу
        })();
    </script>
</body>
</html>
