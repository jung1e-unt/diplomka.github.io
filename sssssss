@page
@model IndexModel
@{
    ViewData["Title"] = "OTCH";
    Layout = null;
}
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="utf-8" />
    <title>@ViewData["Title"]</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link href="~/css/site.css" rel="stylesheet" />
</head>
<body>

    <div class="layout">
        <aside class="sidebar">
            <h3>Таблицы</h3>

            <div class="dropdown" id="tableDropdown">
                <button class="dropdown-toggle" id="tablePickerToggle">Выбрать таблицы ▾</button>
                <div class="dropdown-menu" id="tablePickerMenu">
                    <div class="dropdown-header">
                        <input id="tableSearch" class="dropdown-search" type="text" placeholder="Поиск по таблицам" />
                    </div>

                    <div class="dropdown-groups" id="tableGroups"></div>

                    <div class="dropdown-actions">
                        <button id="selectAllBtn">Выбрать все</button>
                        <button id="clearAllBtn">Сбросить все</button>
                        <button id="applySelectionBtn" class="btn">Применить</button>
                    </div>
                </div>
            </div>

            <div class="selected-wrap">
                <div class="selected-title">Выбранные таблицы</div>
                <div class="selected-list" id="selectedTables">
                    <div class="hint-p">Пока ничего не выбрано</div>
                </div>
            </div>
        </aside>

        <main class="content">



            <div style="margin-bottom:10px;">
                <h4>Конструктор SQL-запроса</h4>
                <textarea id="sqlQuery" rows="4" style="width:100%;" placeholder="Введите SQL (только SELECT)"></textarea>
                <br>
                <button id="runSqlBtn">Выполнить SQL</button>
            </div>


            <h3>Фильтр</h3>

            <div class="hint" id="filterInfo">
                Сначала выберите таблицу слева. После выбора таблицы станет доступен фильтр по датам.
            </div>

            <div class="toolbar">
                <div style="display:flex; gap:8px; width: 100%; max-width: 540px;">
                    <div style="flex:1;">
                        <label for="startDate">Дата от</label>
                        <input id="startDate" type="date" disabled />
                    </div>
                    <div style="flex:1;">
                        <label for="endDate">Дата до</label>
                        <input id="endDate" type="date" disabled />
                    </div>
                </div>

                <button id="applyFilterBtn" class="btn" disabled>Применить фильтр</button>
                <button id="resetFilterBtn" class="btn-secondary" disabled>Очистить фильтр</button>
            </div>


            <div id="nPartWrap" style="display:none;">
                <label>N_PART:</label>
                <input type="text" id="nPart" placeholder="номер партии" />
            </div>

            <div id="nPlawWrap" style="display:none;">
                <label>N_PLAW:</label>
                <input type="text" id="nPlaw" placeholder="номер плавки" />
            </div>


            <h3>Данные</h3>
            <div id="content">
                <div class="hint">Выберите таблицу слева, затем задайте даты и нажмите «Применить фильтр».</div>
            </div>
        </main>
    </div>



    <script>
        const dataBaseUrl   = '@Url.Page("./Index", "Data")';
        const exportBaseUrl = '@Url.Page("./Index", "Export")';

        const tables = [
            "lnpp.ANGA_OTK","lnpp.AUO_OPXR","lnpp.BMC_1_2","lnpp.DATACENTR","lnpp.DATACENTR_OLD","lnpp.EXCEL3","lnpp.GEST","lnpp.JA_1","lnpp.JA_2","lnpp.JASH_1",
        "lnpp.JASH_1_DUBL","lnpp.JASH_2","lnpp.JASH_2_DUBL","lnpp.LAB_LNPP","lnpp.LNGC_DATACENTR","lnpp.LNGC_OTK","lnpp.LNGC_OTK_DUBLE","lnpp.LPC3_MM",
        "lnpp.MEX_CGCA","lnpp.MEX_CGCA_LOG","lnpp.MEX_LAB_OB","lnpp.MEX_LPC1","lnpp.MEX_LPC1_DUBLE","lnpp.MEX_LPC1_LOG","lnpp.MEX_LPC2","lnpp.MEX_LPC2_LOG",
        "lnpp.MEX_LPC3","lnpp.MEX_LPC3_LOG","lnpp.MEX_LPC3_UCH","lnpp.MEX_LPC3_UCH_LOG","lnpp.MEX_SPC","lnpp.MEX_TRUBN","lnpp.MEX_TRUBN_LOG","lnpp.MICRO_CGCA",
        "lnpp.MICRO_LPC1","lnpp.MICRO_LPC1_NEW","lnpp.MICRO_LPC2","lnpp.MICRO_LPC3","lnpp.NDC_DUBLE_LNPP","lnpp.NDC_LNPP","lnpp.OTGR_CGCA","lnpp.OTGR_CGCA_NEW",
        "lnpp.OTGR_CGCA_OLD","lnpp.OTK","lnpp.PROD_LNPP","lnpp.PROD_LNPP_OLD","lnpp.PROIZ_LPC3","lnpp.PROIZV_ANGA","lnpp.PROIZV_ANGA_PRODUCTIV","lnpp.PROIZV_CGCA",
        "lnpp.PROIZV_LKPP_OLD","lnpp.PROIZV_LNGC","lnpp.PROIZV_LNGC_PRODUCTIV","lnpp.PROIZV_LNPP","lnpp.PROIZV_LNPP_OLD","lnpp.PROIZV_LNPP_PROD_NEW",
        "lnpp.PROIZV_LNPP_PRODUCTIV","lnpp.PROKAT_SMAZ","lnpp.PRPROKAT_CEXA","lnpp.RASTVOR_LNPP","lnpp.RASTVOR_OPXR2",
        "lnpp.VOZV_OTGR","lnpp.XIM_VODA","lnpp.XIMBXU_LPC2","lnpp.XIMKISLOTA_LPC2","lnpp.XIMMASLO_LPC2","lnpp.XIMMUL_LPC2","lnpp.XIMNTA_LPC2","lnpp.XIMVXKONTR_LPC3",
        "lnpp.XIMXROM_LPC3"
    ];




        const groups = {
          "ANGA": ["lnpp.ANGA_OTK"],
              "AUO": ["lnpp.AUO_OPXR"],
              "BMC": ["lnpp.BMC_1_2"],
                  "DATACENTR": ["lnpp.DATACENTR","lnpp.DATACENTR_OLD"],
          "EXCEL": ["lnpp.EXCEL3"],
              "JA": ["lnpp.JA_1","lnpp.JA_2"],
                          "JASH": ["lnpp.JASH_1","lnpp.JASH_1_DUBL","lnpp.JASH_2","lnpp.JASH_2_DUBL"],
              "LAB_LNPP": ["lnpp.LAB_LNPP"],
                      "LNGC": ["lnpp.LNGC_DATACENTR","lnpp.LNGC_OTK","lnpp.LNGC_OTK_DUBLE"],
              "LPC3_MM": ["lnpp.LPC3_MM"],
                                  "MEX": ["lnpp.MEX_CGCA","lnpp.MEX_CGCA_LOG","lnpp.MEX_LAB_OB","lnpp.MEX_LPC1","lnpp.MEX_LPC1_DUBLE","lnpp.MEX_LPC1_LOG",
                                          "lnpp.MEX_LPC2","lnpp.MEX_LPC2_LOG","lnpp.MEX_LPC3","lnpp.MEX_LPC3_LOG","lnpp.MEX_LPC3_UCH","lnpp.MEX_LPC3_UCH_LOG",
                              "lnpp.MEX_SPC","lnpp.MEX_TRUBN","lnpp.MEX_TRUBN_LOG"],
                              "MICRO": ["lnpp.MICRO_CGCA","lnpp.MICRO_LPC1","lnpp.MICRO_LPC1_NEW","lnpp.MICRO_LPC2","lnpp.MICRO_LPC3"],
                  "NDC": ["lnpp.NDC_DUBLE_LNPP","lnpp.NDC_LNPP"],
                          "OTGR": ["lnpp.OTGR_CGCA","lnpp.OTGR_CGCA_NEW","lnpp.OTGR_CGCA_OLD","lnpp.VOZV_OTGR"],
              "OTK": ["lnpp.OTK"],
                  "PROD": ["lnpp.PROD_LNPP","lnpp.PROD_LNPP_OLD"],
                              "PROIZ": ["lnpp.PROIZ_LPC3","lnpp.PROIZV_ANGA","lnpp.PROIZV_ANGA_PRODUCTIV","lnpp.PROIZV_CGCA","lnpp.PROIZV_LKPP_OLD",
                                    "lnpp.PROIZV_LNGC","lnpp.PROIZV_LNGC_PRODUCTIV","lnpp.PROIZV_LNPP","lnpp.PROIZV_LNPP_OLD",
                            "lnpp.PROIZV_LNPP_PROD_NEW","lnpp.PROIZV_LNPP_PRODUCTIV"],
                  "PROKAT": ["lnpp.PROKAT_SMAZ","lnpp.PRPROKAT_CEXA"],
                  "RASTVOR": ["lnpp.RASTVOR_LNPP","lnpp.RASTVOR_OPXR2"],
                  "TEMP": ["lnpp.TEMP_NDC_020147","lnpp.TEMP_NDC_NNN"],
              "VOZV": ["lnpp.VOZV_OTGR"],
                          "XIM": ["lnpp.XIM_VODA","lnpp.XIMBXU_LPC2","lnpp.XIMKISLOTA_LPC2","lnpp.XIMMASLO_LPC2",
                                  "lnpp.XIMMUL_LPC2","lnpp.XIMNTA_LPC2","lnpp.XIMVXKONTR_LPC3","lnpp.XIMXROM_LPC3"]
        };



        let currentTable = null;
        let lastLoadedWithFilter = false;

        const $id = (id) => document.getElementById(id);
        const escapeHtml = (s) => String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;')
                                           .replace(/>/g,'&gt;').replace(/"/g,'&quot;')
                                           .replace(/'/g,'&#39;');
        const escapeAttr = (s) => String(s).replace(/"/g,'&quot;').replace(/'/g,'&#39;');
        const formatValue = (v) => v == null ? '' : String(v);

        function parseFilenameFromCD(cd){
          if (!cd) return null;
          const m = cd.match(/filename\*=UTF-8''([^;]+)|filename="?([^\";]+)"?/i);
          if (!m) return null;
          const raw = m[1] || m[2];
          try { return decodeURIComponent(raw); } catch { return raw; }
        }
        function formatNowForFile(){
          const d = new Date();
          return `${String(d.getDate()).padStart(2,'0')}.${String(d.getMonth()+1).padStart(2,'0')}.${String(d.getFullYear()).slice(-2)}`;
        }

        function groupTablesByLetter(arr){
          const map = new Map();
          for (const t of arr){
            const first = t[0]?.toUpperCase() ?? '#';
            const key = /[A-ZА-ЯЁ]/.test(first) ? first : '#';
            if (!map.has(key)) map.set(key, []);
            map.get(key).push(t);
          }
          return Array.from(map.entries()).sort((a,b)=>a[0].localeCompare(b[0],'ru'));
        }




        window.__tableHasPart = new Set();
        window.__tableHasPlaw = new Set();

        async function getTablesMeta() {
            try {
                const res = await fetch('/Index?handler=TablesState');
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                return await res.json(); 
            } catch (err) {
                console.warn('TablesState недоступен, рендерим группы без фильтра по наличию данных. Детали:', err);
                return null; 
            }
        }

        async function renderGroups() {
            const groupsEl = $id('tableGroups');
            const meta = await getTablesMeta(); 
            let hasDataSet = null;

            if (meta && Array.isArray(meta)) {
                hasDataSet = new Set(meta.filter(m => m.hasData).map(m => m.table));
                window.__tableHasPart = new Set(meta.filter(m => m.hasPart).map(m => m.table));
                window.__tableHasPlaw = new Set(meta.filter(m => m.hasPlaw).map(m => m.table));
            }

            groupsEl.innerHTML = Object.entries(groups).map(([groupName, items]) => {
                const names = hasDataSet ? items.filter(name => hasDataSet.has(name)) : items;
                if (names.length === 0) return ''; // пустая группа не рендерится

                return `
                <section class="group" data-name="${groupName}">
                    <div class="group-header">
                        <div class="group-title">${groupName}</div>
                        <div class="group-actions">
                            <button type="button" class="group-select" data-name="${groupName}">Все</button>
                            <button type="button" class="group-clear"  data-name="${groupName}">Сброс</button>
                        </div>
                    </div>
                    <div class="group-items">
                        ${names.map(name => `
                            <label class="group-item">
                                <input type="checkbox" data-table="${name}"/>
                                <span>${name}</span>
                            </label>
                        `).join('')}
                    </div>
                </section>`;
            }).join('');
        }

        function enableFilters(enabled){
            const startDate = $id('startDate');
            const endDate   = $id('endDate');
            const applyBtn  = $id('applyFilterBtn');
            const resetBtn  = $id('resetFilterBtn');
            const info      = $id('filterInfo');

            if (startDate) startDate.disabled = !enabled;
            if (endDate)   endDate.disabled   = !enabled;
            if (applyBtn)  applyBtn.disabled  = !enabled;
            if (resetBtn)  resetBtn.disabled  = !enabled;
            if (info) info.textContent = enabled ? `Выбрана таблица: ${currentTable}.` : 'Сначала выберите таблицу слева.';

            const sqlBox   = $id('sqlQuery');
            const runSqlBtn= $id('runSqlBtn');
            if (sqlBox)    sqlBox.disabled    = !enabled;
            if (runSqlBtn) runSqlBtn.disabled = !enabled;

            // Показ/скрытие N_PART / N_PLAW при наличии таких столбцов (если используете эти поля)
            syncExtraFilters(currentTable);
        }

        function syncExtraFilters(table){
            const npWrap = $id('nPartWrap');
            const nlWrap = $id('nPlawWrap');
            const hasPart = !!(table && window.__tableHasPart?.has(table));
            const hasPlaw = !!(table && window.__tableHasPlaw?.has(table));

            if (npWrap) {
                npWrap.style.display = hasPart ? '' : 'none';
                if (!hasPart) { const np = $id('nPart'); if (np) np.value = ''; }
            }
            if (nlWrap) {
                nlWrap.style.display = hasPlaw ? '' : 'none';
                if (!hasPlaw) { const nl = $id('nPlaw'); if (nl) nl.value = ''; }
            }
        }

        function collectFilterParams(){
            const sd = ($id('startDate')?.value || '').trim();
            const ed = ($id('endDate')?.value   || '').trim();
            const np = ($id('nPart')?.value     || '').trim();
            const nl = ($id('nPlaw')?.value     || '').trim();

            const params = new URLSearchParams();
            if (sd) params.set('startDate', sd);
            if (ed) params.set('endDate', ed);
            if (np) params.set('nPart',     np);
            if (nl) params.set('nPlaw',     nl);
            return params;
        }

        function renderSelectedButtons(names){
            const box = $id('selectedTables');
            if(!names || names.length===0){
                box.innerHTML = '<div class="hint-p">Пока ничего не выбрано</div>';
                currentTable = null;
                enableFilters(false);
                $id('content').innerHTML = '<div class="hint">Выберите таблицу слева.</div>';
                return;
            }
            names.sort((a,b)=>a.localeCompare(b,'ru'));
            box.innerHTML = names.map(name=>`
                <button class="selected-btn" data-table="${name}">
                    ${name}
                    <span class="selected-remove" data-remove="${name}">✕</span>
                </button>
            `).join('');

            box.querySelectorAll('.selected-btn').forEach(btn=>{
                btn.addEventListener('click', e=>{
                    const rm = e.target.closest('[data-remove]');
                    if(rm){
                        const removed = rm.dataset.remove;
                        const rest = names.filter(n => n !== removed);
                        renderSelectedButtons(rest);
                        const checkbox = document.querySelector(`input[data-table="${removed}"]`);
                        if (checkbox) checkbox.checked = false;
                        if (currentTable === removed) {
                            currentTable = null;
                            enableFilters(false);
                            $id('content').innerHTML = '<div class="hint">Выберите таблицу слева.</div>';
                        }
                        return;
                    }
                    currentTable = btn.dataset.table;
                    lastLoadedWithFilter = false;
                    enableFilters(true);
                    loadTable(currentTable, true);
                });
            });
        }

        function installHandlers(){
            const toggle   = $id('tablePickerToggle');
            const menu     = $id('tablePickerMenu');
            const search   = $id('tableSearch');
            const groupsEl = $id('tableGroups');

            // Открытие/закрытие меню выбора таблиц
            if (toggle) {
                toggle.addEventListener('click', ()=>menu.classList.toggle('open'));
                document.addEventListener('click', e=>{
                    if(!menu.contains(e.target) && !toggle.contains(e.target)) menu.classList.remove('open');
                });
            }

            // Поиск по списку таблиц
            if (search) {
                search.addEventListener('input', ()=>{
                    const q = search.value.toLowerCase();
                    for(const item of groupsEl.querySelectorAll('.group-item')){
                        item.style.display = item.textContent.toLowerCase().includes(q)?'':'none';
                    }
                });
            }

            groupsEl.addEventListener('click', e=>{
                const btn = e.target.closest('button.group-select,button.group-clear');
                if(!btn) return;
                const groupName = btn.dataset.name; // <-- ВАЖНО: data-name из renderGroups
                const section = groupsEl.querySelector(`.group[data-name="${groupName}"]`);
                const check = btn.classList.contains('group-select');
                for(const cb of section.querySelectorAll('input[type="checkbox"]')) cb.checked = check;
            });

            // Выбрать все / очистить все (по всем группам)
            const selectAllBtn = $id('selectAllBtn');
            const clearAllBtn  = $id('clearAllBtn');
            if (selectAllBtn) selectAllBtn.addEventListener('click',()=>{
                for(const cb of groupsEl.querySelectorAll('input[type="checkbox"]')) cb.checked = true;
            });
            if (clearAllBtn) clearAllBtn.addEventListener('click',()=>{
                for(const cb of groupsEl.querySelectorAll('input[type="checkbox"]')) cb.checked = false;
            });

            // Применить выбор таблиц
            const applySelectionBtn = $id('applySelectionBtn');
            if (applySelectionBtn) applySelectionBtn.addEventListener('click',()=>{
                const selected = Array.from(groupsEl.querySelectorAll('input[type="checkbox"]:checked')).map(cb => cb.dataset.table);
                renderSelectedButtons(selected);
                if (menu) menu.classList.remove('open');
            });

            // Применить/сброс фильтра (по датам + доп. поля)
            const applyFilterBtn = $id('applyFilterBtn');
            const resetFilterBtn = $id('resetFilterBtn');
            if (applyFilterBtn) applyFilterBtn.addEventListener('click', ()=>{
                if(!currentTable){
                    showErrorModal('Сначала выберите таблицу слева.');
                    return;
                }
                lastLoadedWithFilter = true;
                loadTable(currentTable, false);
            });
            if (resetFilterBtn) resetFilterBtn.addEventListener('click', ()=>{
                const sd = $id('startDate'); const ed = $id('endDate');
                const np = $id('nPart');     const nl = $id('nPlaw');
                if (sd) sd.value = '';
                if (ed) ed.value = '';
                if (np) np.value = '';
                if (nl) nl.value = '';
                enableFilters(!!currentTable);
            });

            // Конструктор SQL (только SELECT + проверка выбранной таблицы)
            const runSqlBtn = $id('runSqlBtn');
            if (runSqlBtn) {
                runSqlBtn.addEventListener('click', async () => {
                    const sqlBox = $id('sqlQuery');
                    const sql = (sqlBox?.value || '').trim();
                    if (!sql) { showErrorModal('Введите SQL-запрос!'); return; }
                    if (!sql.toUpperCase().startsWith('SELECT')) { showErrorModal('Разрешены только SELECT-запросы.'); return; }
                    if (!currentTable) { showErrorModal('Сначала выберите таблицу слева.'); return; }

                    const content = $id('content');
                    content.innerHTML = `<div class="spinner">Выполнение SQL-запроса…</div>`;
                    setExportEnabled(false);

                    try {
                        const url = `/Index?handler=RunSql&sql=${encodeURIComponent(sql)}&currentTable=${encodeURIComponent(currentTable)}`;
                        const res = await fetch(url);
                        const data = await res.json();

                        if (data.error) {
                            showErrorModal('Ошибка выполнения SQL: ' + data.error);
                            content.innerHTML = `<div class="error">${escapeHtml(data.error)}</div>`;
                            return;
                        }

                        if (!Array.isArray(data) || data.length === 0) {
                            content.innerHTML = `
                                <h3>Результат SQL</h3>
                                <div class="toolbar">
                                    <button id="exportBtn" class="btn" disabled>Экспорт в Excel</button>
                                </div>
                                <p class="hint">Нет данных.</p>`;
                            return;
                        }

                        const columns = Object.keys(data[0]);
                        const thead = `<thead><tr>${columns.map(c => `<th>${escapeHtml(c)}</th>`).join('')}</tr></thead>`;
                        const tbody = `<tbody>${data.map(row => `<tr>${columns.map(c => `<td>${escapeHtml(formatValue(row[c]))}</td>`).join('')}</tr>`).join('')}</tbody>`;

                        content.innerHTML = `
                            <h3>Результат SQL</h3>
                            <div class="toolbar">
                                <button id="exportBtn" class="btn" onclick="exportExcelSql('${escapeAttr(sql)}')">Экспорт в Excel</button>
                            </div>
                            <div class="table-wrap"><table>${thead}${tbody}</table></div>`;
                        setExportEnabled(true);
                    } catch (err) {
                        showErrorModal('Ошибка загрузки данных: ' + err.message);
                        content.innerHTML = `<div class="error">Ошибка: ${escapeHtml(err.message)}</div>`;
                    }
                });
            }
        }

        function setExportEnabled(enabled){
            const btn = document.getElementById('exportBtn');
            if (!btn) return;
            btn.disabled = !enabled;
        }

        async function loadTable(table, initial){
            const content = $id('content');
            content.innerHTML = `<div class="spinner">Загрузка данных из ${escapeHtml(table)}…</div>`;
            setExportEnabled(false);
            try{
                const base = `${dataBaseUrl}&table=${encodeURIComponent(table)}`;
                const params = collectFilterParams();
                const url = initial ? base : `${base}&${params.toString()}`;

                const res = await fetch(url);
                const data = await res.json();

                const sd = ($id('startDate')?.value || '').trim().replace(/-/g, '.');
                const ed = ($id('endDate')?.value   || '').trim().replace(/-/g, '.');
                const np = ($id('nPart')?.value     || '').trim();
                const nl = ($id('nPlaw')?.value     || '').trim();

                const hasAnyFilter = (!initial) && (sd || ed || np || nl);
                const filterBadge = hasAnyFilter
                    ? `<span class="hint">Фильтр: ${sd || 'Не указана дата от'} - ${ed || 'Не указана дата до'}${(np||nl)?`, N_PART=${np||'Не указано'}, N_PLAW=${nl||'Не указано'}`:''}</span>`
                    : `<span class="hint">Без фильтра</span>`;

                if (!Array.isArray(data) || data.length===0){
                    content.innerHTML = `
                        <h3>${escapeHtml(table)} ${filterBadge}</h3>
                        <div class="toolbar">
                            <button id="exportBtn" class="btn" disabled onclick="exportExcel('${escapeAttr(table)}')">Экспорт в Excel</button>
                        </div>
                        <p class="hint">Нет данных.</p>`;
                    return;
                }

                const columns = Object.keys(data[0]);
                const thead = `<thead><tr>${columns.map(c=>`<th>${escapeHtml(c)}</th>`).join('')}</tr></thead>`;
                const tbody = `<tbody>${data.map(row=>`<tr>${columns.map(c=>`<td>${escapeHtml(formatValue(row[c]))}</td>`).join('')}</tr>`).join('')}</tbody>`;

                content.innerHTML = `
                    <h3>${escapeHtml(table)} ${filterBadge}</h3>
                    <div class="toolbar">
                        <button id="exportBtn" class="btn" onclick="exportExcel('${escapeAttr(table)}')">Экспорт в Excel</button>
                    </div>
                    <div class="table-wrap"><table>${thead}${tbody}</table></div>`;
                setExportEnabled(true);
            } catch(err){
                showErrorModal('Ошибка загрузки данных: ' + err.message);
                content.innerHTML = `<div class="error">Ошибка: ${escapeHtml(err.message)}</div>`;
                setExportEnabled(false);
            }
        }

        const exportModal = document.createElement("div");
        exportModal.className = "export-modal";
        exportModal.innerHTML = `
            <div class="export-modal-box">
                <div class="export-text">Пожалуйста, подождите…</div>
            </div>
        `;
        document.body.appendChild(exportModal);

        function showExportModal(){ exportModal.classList.add("open"); }
        function hideExportModal(){ exportModal.classList.remove("open"); }

        const errorModal = document.createElement("div");
        errorModal.className = "error-modal";
        errorModal.innerHTML = `
            <div class="error-modal-box">
                <div id="error-text" class="error-text">Ошибка!</div>
                <button id="error-close" class="error-close">Закрыть</button>
            </div>
        `;
        document.body.appendChild(errorModal);

        function showErrorModal(message) {
            const t = document.getElementById('error-text');
            if (t) t.textContent = message;
            errorModal.classList.add("open");
        }
        document.getElementById('error-close').onclick = function() {
            errorModal.classList.remove("open");
        };
        window.onclick = function(event) {
            if (event.target === errorModal) {
                errorModal.classList.remove("open");
            }
        };

        window.exportExcelSql = async function(sql){
            showExportModal();
            try {
                const url = `/Index?handler=ExportSql&sql=${encodeURIComponent(sql)}&currentTable=${encodeURIComponent(currentTable)}`;
                const resp = await fetch(url);
                const cd = resp.headers.get('Content-Disposition') || '';
                const m = cd.match(/filename\*=UTF-8''([^;]+)|filename="?([^\";]+)"?/i);
                const raw = m ? (m[1] || m[2]) : null;
                const name = raw ? decodeURIComponent(raw) : `SQL_${formatNowForFile()}.xlsx`;
                const blob = await resp.blob();
                const blobUrl = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = blobUrl;
                a.download = name;
                document.body.appendChild(a);
                a.click();
                a.remove();
                URL.revokeObjectURL(blobUrl);
            } catch (err){
                showErrorModal('Ошибка экспорта данных: ' + err.message);
            } finally{
                hideExportModal();
            }
        };

        function formatNowForFile(){
            const d = new Date();
            return `${d.getFullYear()}-${(d.getMonth()+1).toString().padStart(2,'0')}-${d.getDate().toString().padStart(2,'0')}_${d.getHours().toString().padStart(2,'0')}-${d.getMinutes().toString().padStart(2,'0')}`;
        }

        (async function init(){
            await renderGroups();    
            installHandlers();        
            enableFilters(false);     
            renderSelectedButtons([]);
            window.exportExcel = exportExcel; 
        })();
    </script>

</body>
</html>

using ClosedXML.Excel;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.RazorPages;
using Microsoft.Extensions.Configuration;
using Oracle.ManagedDataAccess.Client;
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text.Json;

public class IndexModel : PageModel
{
    private readonly IConfiguration _config;

    public IndexModel(IConfiguration config)
    {
        _config = config;
    }

    // Разрешённые таблицы
    public static readonly HashSet<string> AllowedTables = new(StringComparer.OrdinalIgnoreCase)
    {
        "lnpp.ANGA_OTK","lnpp.AUO_OPXR","lnpp.BMC_1_2","lnpp.DATACENTR","lnpp.DATACENTR_OLD","lnpp.EXCEL3","lnpp.GEST","lnpp.JA_1","lnpp.JA_2","lnpp.JASH_1",
    "lnpp.JASH_1_DUBL","lnpp.JASH_2","lnpp.JASH_2_DUBL","lnpp.LAB_LNPP","lnpp.LNGC_DATACENTR","lnpp.LNGC_OTK","lnpp.LNGC_OTK_DUBLE","lnpp.LPC3_MM",
    "lnpp.MEX_CGCA","lnpp.MEX_CGCA_LOG","lnpp.MEX_LAB_OB","lnpp.MEX_LPC1","lnpp.MEX_LPC1_DUBLE","lnpp.MEX_LPC1_LOG","lnpp.MEX_LPC2","lnpp.MEX_LPC2_LOG",
    "lnpp.MEX_LPC3","lnpp.MEX_LPC3_LOG","lnpp.MEX_LPC3_UCH","lnpp.MEX_LPC3_UCH_LOG","lnpp.MEX_SPC","lnpp.MEX_TRUBN","lnpp.MEX_TRUBN_LOG","lnpp.MICRO_CGCA",
    "lnpp.MICRO_LPC1","lnpp.MICRO_LPC1_NEW","lnpp.MICRO_LPC2","lnpp.MICRO_LPC3","lnpp.NDC_DUBLE_LNPP","lnpp.NDC_LNPP","lnpp.OTGR_CGCA","lnpp.OTGR_CGCA_NEW",
    "lnpp.OTGR_CGCA_OLD","lnpp.OTK","lnpp.PROD_LNPP","lnpp.PROD_LNPP_OLD","lnpp.PROIZ_LPC3","lnpp.PROIZV_ANGA","lnpp.PROIZV_ANGA_PRODUCTIV","lnpp.PROIZV_CGCA",
    "lnpp.PROIZV_LKPP_OLD","lnpp.PROIZV_LNGC","lnpp.PROIZV_LNGC_PRODUCTIV","lnpp.PROIZV_LNPP","lnpp.PROIZV_LNPP_OLD","lnpp.PROIZV_LNPP_PROD_NEW",
    "lnpp.PROIZV_LNPP_PRODUCTIV","lnpp.PROKAT_SMAZ","lnpp.PRPROKAT_CEXA","lnpp.RASTVOR_LNPP","lnpp.RASTVOR_OPXR2",
    "lnpp.VOZV_OTGR","lnpp.XIM_VODA","lnpp.XIMBXU_LPC2","lnpp.XIMKISLOTA_LPC2","lnpp.XIMMASLO_LPC2","lnpp.XIMMUL_LPC2","lnpp.XIMNTA_LPC2","lnpp.XIMVXKONTR_LPC3",
    "lnpp.XIMXROM_LPC3"
    };

    private static readonly Dictionary<string, string> DefaultDateColumnByTable =

new(StringComparer.OrdinalIgnoreCase)
{
    ["lnpp.ANGA_OTK"] = "DATA",
    ["lnpp.AUO_OPXR"] = "DATA_ID",
    ["lnpp.BMC_1_2"] = "DATA_ID",
    ["lnpp.DATACENTR"] = "SAMPLE_DATETIME",
    ["lnpp.DATACENTR_OLD"] = "SAMPLE_DATETIME",
    ["lnpp.EXCEL3"] = "",
    ["lnpp.GEST"] = "DATA_ID",
    ["lnpp.JA_1"] = "SAMPLE_DATETIME",
    ["lnpp.JA_2"] = "SAMPLE_DATETIME",
    ["lnpp.JASH_1"] = "SAMPLE_DATETIME",
    ["lnpp.JASH_1_DUBL"] = "SAMPLE_DATETIME",
    ["lnpp.JASH_2"] = "SAMPLE_DATETIME",
    ["lnpp.JASH_2_DUBL"] = "SAMPLE_DATETIME",
    ["lnpp.LAB_LNPP"] = "DATA",
    ["lnpp.LNGC_DATACENTR"] = "SAMPLE_DATETIME",
    ["lnpp.LNGC_OTK"] = "DATA",
    ["lnpp.LNGC_OTK_DUBLE"] = "SAMPLE_DATETIME",
    ["lnpp.LPC3_MM"] = "DATA_PR",
    ["lnpp.MEX_CGCA"] = "DATA_ID",
    ["lnpp.MEX_CGCA_LOG"] = "DATA_ID",
    ["lnpp.MEX_LAB_OB"] = "DATA_ID_CG",
    ["lnpp.MEX_LPC1"] = "DATA_ID",
    ["lnpp.MEX_LPC1_DUBLE"] = "DATA_ID",
    ["lnpp.MEX_LPC1_LOG"] = "DATA_ID",
    ["lnpp.MEX_LPC2"] = "DATA_ID",
    ["lnpp.MEX_LPC2_LOG"] = "DATA_ID",
    ["lnpp.MEX_LPC3"] = "DATA_ID",
    ["lnpp.MEX_LPC3_LOG"] = "DATA_ID",
    ["lnpp.MEX_LPC3_UCH"] = "DATA_ID",
    ["lnpp.MEX_LPC3_UCH_LOG"] = "DATA_ID",
    ["lnpp.MEX_SPC"] = "DATA_ID",
    ["lnpp.MEX_TRUBN"] = "DATA_ID",
    ["lnpp.MEX_TRUBN_LOG"] = "DATA_ID",
    ["lnpp.MICRO_CGCA"] = "CREATED_ID",
    ["lnpp.MICRO_LPC1"] = "CREATED_ID",
    ["lnpp.MICRO_LPC1_NEW"] = "DATE_MICRO",
    ["lnpp.MICRO_LPC2"] = "CREATED_DATE",
    ["lnpp.MICRO_LPC3"] = "CREATED_DATE",
    ["lnpp.NDC_DUBLE_LNPP"] = "SAMPLE_DATETIME",
    ["lnpp.NDC_LNPP"] = "SAMPLE_DATETIME",
    ["lnpp.OTGR_CGCA"] = "DATA_CEHA",
    ["lnpp.OTGR_CGCA_NEW"] = "DATA_CEHA",
    ["lnpp.OTGR_CGCA_OLD"] = "DATA_CEHA",
    ["lnpp.OTK"] = "DATA",
    ["lnpp.PROD_LNPP"] = "DATE_NACH",
    ["lnpp.PROD_LNPP_OLD"] = "DATA",
    ["lnpp.PROIZ_LPC3"] = "DATA",
    ["lnpp.PROIZV_ANGA"] = "DATA",
    ["lnpp.PROIZV_ANGA_PRODUCTIV"] = "DATA",
    ["lnpp.PROIZV_CGCA"] = "DATA",
    ["lnpp.PROIZV_LKPP_OLD"] = "DATA",
    ["lnpp.PROIZV_LNGC"] = "DATA",
    ["lnpp.PROIZV_LNGC_PRODUCTIV"] = "DATA",
    ["lnpp.PROIZV_LNPP"] = "DATA",
    ["lnpp.PROIZV_LNPP_OLD"] = "DATA",
    ["lnpp.PROIZV_LNPP_PROD_NEW"] = "DATA",
    ["lnpp.PROIZV_LNPP_PRODUCTIV"] = "DATA",
    ["lnpp.PROKAT_SMAZ"] = "DATA_ID",
    ["lnpp.PRPROKAT_CEXA"] = "DATA_ID",
    ["lnpp.RASTVOR_LNPP"] = "DATA",
    ["lnpp.RASTVOR_OPXR2"] = "DATA_ID",
    ["lnpp.VOZV_OTGR"] = "DATE_CREATE",
    ["lnpp.XIM_VODA"] = "DATA_ID",
    ["lnpp.XIMBXU_LPC2"] = "DATA_ID",
    ["lnpp.XIMKISLOTA_LPC2"] = "DATA_ID",
    ["lnpp.XIMMASLO_LPC2"] = "DATA_ID",
    ["lnpp.XIMMUL_LPC2"] = "DATA_ID",
    ["lnpp.XIMNTA_LPC2"] = "DATA_ID",
    ["lnpp.XIMVXKONTR_LPC3"] = "DATA_ID",
    ["lnpp.XIMXROM_LPC3"] = "DATA_ID"
};


    private static readonly HashSet<string> DefaultExcludeColumns =
        new(StringComparer.OrdinalIgnoreCase)
        {
            "ORA_ROWSCN","SYS_CREATION_DATE","SYS_UPDATE_DATE"
        };

    private const string ContentTypeXlsx = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";


    public IActionResult OnGetData(
        string table,
        string? startDate,
        string? endDate,
        string? nPart,
        string? nPlaw,
        int? offset,          // <- добавлено
        int? pageSize         // <- добавлено
    )
    {
        if (string.IsNullOrWhiteSpace(table))
            return new JsonResult(new { error = "Table is required." }) { StatusCode = 400 };

        var tableUpper = table.Trim().ToUpperInvariant();
        if (!AllowedTables.Contains(tableUpper))
            return new JsonResult(new { error = "Table is not allowed." }) { StatusCode = 400 };

        var dateColumn = ResolveDateColumn(tableUpper);
        var start = ParseDate(startDate);
        var end = ParseDate(endDate);

        // Значения по умолчанию
        var take = Math.Clamp(pageSize ?? 100, 1, 1000); // не даём запросить слишком много за раз
        var skip = Math.Max(offset ?? 0, 0);

        var connString = _config.GetConnectionString("OracleConnection");
        using var conn = new OracleConnection(connString);
        conn.Open();

        try
        {
            var columns = GetColumns(conn, tableUpper, DefaultExcludeColumns);
            if (!columns.Any(c => string.Equals(c, dateColumn, StringComparison.OrdinalIgnoreCase)))
                return new JsonResult(new { error = $"Колонка даты '{dateColumn}' отсутствует в {tableUpper}." }) { StatusCode = 500 };

            // ОБЯЗАТЕЛЬНО: выберем надёжный столбец сортировки.
            // Предпочтительно — дата, указанная в ResolveDateColumn.
            // Если даты нет, можно использовать первый столбец.
            var orderBy = dateColumn;
            if (string.IsNullOrWhiteSpace(orderBy) || !columns.Contains(orderBy, StringComparer.OrdinalIgnoreCase))
                orderBy = columns[0];

            var sql = BuildSqlPaged(tableUpper, columns, dateColumn, start, end, nPart, nPlaw, orderBy, skip, take);

            using var cmd = new OracleCommand(sql, conn);
            BindDateParams(cmd, start, end);

            if (!string.IsNullOrWhiteSpace(nPart) && columns.Any(c => string.Equals(c, "N_PART", StringComparison.OrdinalIgnoreCase)))
                cmd.Parameters.Add(new OracleParameter("pNPart", nPart));

            if (!string.IsNullOrWhiteSpace(nPlaw) && columns.Any(c => string.Equals(c, "N_PLAW", StringComparison.OrdinalIgnoreCase)))
                cmd.Parameters.Add(new OracleParameter("pNPlaW", nPlaw));

            var rows = new List<Dictionary<string, object?>>();
            using var reader = cmd.ExecuteReader();
            var schema = reader.GetColumnSchema();
            while (reader.Read())
            {
                var row = new Dictionary<string, object?>(StringComparer.OrdinalIgnoreCase);
                foreach (var col in schema)
                {
                    var raw = reader[col.ColumnName];
                    if (raw == DBNull.Value) row[col.ColumnName] = null;
                    else if (raw is DateTime dt) row[col.ColumnName] = dt.ToString("dd.MM.yy");
                    else row[col.ColumnName] = raw;
                }
                rows.Add(row);
            }

            // Простой способ понять, есть ли ещё данные: запросить на 1 строку больше.
            // Для этого выше можно делать take+1. Здесь покажу логику, если будете брать +1.
            bool hasMore = false;
            if (rows.Count > take)
            {
                hasMore = true;
                rows.RemoveAt(rows.Count - 1);
            }

            return new JsonResult(new
            {
                data = rows,
                nextOffset = skip + rows.Count,
                hasMore
            }, new JsonSerializerOptions { PropertyNamingPolicy = null, WriteIndented = false });
        }
        catch (OracleException ex) when (ex.Number == 8180 || ex.Number == 8181)
        {
            return new JsonResult(new { data = Array.Empty<object>(), nextOffset = skip, hasMore = false });
        }
    }

    private static string BuildSqlPaged(
    string tableUpper,
    IReadOnlyList<string> selectedColumns,
    string dateColumn,
    DateTime? startDate,
    DateTime? endDate,
    string? nPart,
    string? nPlaw,
    string orderBy,
    int offset,
    int pageSize)
    {
        if (selectedColumns is null || selectedColumns.Count == 0)
            throw new ArgumentException("Нужно указать хотя бы одну колонку для SELECT.", nameof(selectedColumns));

        var selectList = string.Join(", ", selectedColumns.Select(c => $"\"{c}\""));

        var filters = new List<string>();

        if (startDate.HasValue && endDate.HasValue)
            filters.Add($"\"{dateColumn}\" BETWEEN :pStart AND :pEnd");
        else if (startDate.HasValue)
            filters.Add($"\"{dateColumn}\" >= :pStart");
        else if (endDate.HasValue)
            filters.Add($"\"{dateColumn}\" <= :pEnd");
        else
            filters.Add($"\"{dateColumn}\" BETWEEN ADD_MONTHS(SYSDATE, -6) AND SYSDATE");

        if (!string.IsNullOrWhiteSpace(nPart) && selectedColumns.Any(c => string.Equals(c, "N_PART", StringComparison.OrdinalIgnoreCase)))
            filters.Add("\"N_PART\" = :pNPart");

        if (!string.IsNullOrWhiteSpace(nPlaw) && selectedColumns.Any(c => string.Equals(c, "N_PLAW", StringComparison.OrdinalIgnoreCase)))
            filters.Add("\"N_PLAW\" = :pNPlaW");

        var where = filters.Count > 0 ? $"WHERE {string.Join(" AND ", filters)}" : string.Empty;

        // ВАЖНО: стабильная сортировка (обычно по дате DESC логичнее для последних записей)
        var order = $"ORDER BY \"{orderBy}\" DESC";

        // Трюк с +1 строкой, чтобы понять hasMore
        var fetch = $"OFFSET {offset} ROWS FETCH NEXT {pageSize + 1} ROWS ONLY";

        var sql = $@"
SELECT {selectList}
FROM {tableUpper}
{where}
{order}
{fetch}";
        return sql;
    }


    public IActionResult OnGetExport(string table, string? startDate, string? endDate,string? nPart,string? nPlaw)
    {
        try
        {
            if (string.IsNullOrWhiteSpace(table))
                return BadRequest("Table is required.");

            var tableUpper = table.Trim().ToUpperInvariant();
            if (!AllowedTables.Contains(tableUpper))
                return BadRequest("Table is not allowed.");

            var dateColumn = ResolveDateColumn(tableUpper);
            var start = ParseDate(startDate);
            var end = ParseDate(endDate);

            var connString = _config.GetConnectionString("OracleConnection");
            using var conn = new OracleConnection(connString);
            conn.Open();

            var columns = GetColumns(conn, tableUpper, DefaultExcludeColumns);
            if (!columns.Any(c => string.Equals(c, dateColumn, StringComparison.OrdinalIgnoreCase)))
                return BadRequest($"Колонка даты '{dateColumn}' отсутствует в {tableUpper}.");

            var sql = BuildSql(tableUpper, columns, dateColumn, start, end, nPart, nPlaw);
            using var cmd = new OracleCommand(sql, conn);
            BindDateParams(cmd, start, end);
            using var reader = cmd.ExecuteReader();

            var dt = ToDataTable(reader);

            using var wb = new XLWorkbook();
            var ws = wb.Worksheets.Add(dt, tableUpper);

            var tbl = ws.Tables.FirstOrDefault();
            if (tbl != null) tbl.ShowAutoFilter = true;

            ws.SheetView.FreezeRows(1);
            ApplyDateColumnFormats(ws, dt);
            ws.Columns().AdjustToContents();

            byte[] bytes;
            using (var ms = new MemoryStream())
            {
                wb.SaveAs(ms);
                bytes = ms.ToArray();
            }

            var fileName = $"{tableUpper}_{DateTime.Now:ddMMyy}.xlsx";
            return File(bytes, ContentTypeXlsx, fileName);
        }
        catch (OracleException ex) when (ex.Number == 8180 || ex.Number == 8181)
        {
            using var wbEmpty = new XLWorkbook();
            var wsEmpty = wbEmpty.Worksheets.Add(table.ToUpperInvariant());
            wsEmpty.Cell(1, 1).Value = "Нет данных";
            wsEmpty.Columns().AdjustToContents();

            byte[] emptyBytes;
            using (var msEmpty = new MemoryStream())
            {
                wbEmpty.SaveAs(msEmpty);
                emptyBytes = msEmpty.ToArray();
            }

            return File(emptyBytes, ContentTypeXlsx, $"{table.ToUpperInvariant()}_{DateTime.Now:ddMMyy}.xlsx");
        }
        catch (Exception ex)
        {
            return StatusCode(500, $"Export failed: {ex.GetType().Name}: {ex.Message}");
        }
    }


    private static string ResolveDateColumn(string tableUpper)
        => DefaultDateColumnByTable.TryGetValue(tableUpper, out var col) ? col : "DT"; // общий дефолт




    private static string BuildSql(
        string tableUpper,
        IReadOnlyList<string> selectedColumns,
        string dateColumn,
        DateTime? startDate,
        DateTime? endDate,
        string? nPart,
        string? nPlav)
    {
        if (selectedColumns is null || selectedColumns.Count == 0)
            throw new ArgumentException("Нужно указать хотя бы одну колонку для SELECT.", nameof(selectedColumns));

        if (string.IsNullOrWhiteSpace(tableUpper))
            throw new ArgumentException("Имя таблицы не может быть пустым.", nameof(tableUpper));

        if (string.IsNullOrWhiteSpace(dateColumn))
            throw new ArgumentException("Имя колонки даты не может быть пустым.", nameof(dateColumn));

        var selectList = string.Join(", ", selectedColumns.Select(c => $"\"{c}\""));
        var parts = new List<string>();

        if (startDate.HasValue && endDate.HasValue)
        {
            parts.Add($"\"{dateColumn}\" BETWEEN :pStart AND :pEnd");
        }
        else if (startDate.HasValue)
        {
            parts.Add($"\"{dateColumn}\" >= :pStart");
        }
        else if (endDate.HasValue)
        {
            parts.Add($"\"{dateColumn}\" <= :pEnd");
        }
        else
        {
            parts.Add($"\"{dateColumn}\" BETWEEN ADD_MONTHS(SYSDATE, -6) AND SYSDATE");
        }

        if (!string.IsNullOrWhiteSpace(nPart) &&
            selectedColumns.Any(c => string.Equals(c, "N_PART", StringComparison.OrdinalIgnoreCase)))
        {
            parts.Add("\"N_PART\" = :pNPart");
        }

        if (!string.IsNullOrWhiteSpace(nPlav) &&
            selectedColumns.Any(c => string.Equals(c, "N_PLAV", StringComparison.OrdinalIgnoreCase)))
        {
            parts.Add("\"N_PLAV\" = :pNPlav");
        }

        var where = parts.Count > 0 ? $"WHERE {string.Join(" AND ", parts)}" : string.Empty;

        var sql = $@"
SELECT {selectList}
FROM {tableUpper}
{where}";

        return sql;
    }


    private static void BindDateParams(OracleCommand cmd, DateTime? startDate, DateTime? endDate)
    {
        if (startDate.HasValue)
            cmd.Parameters.Add(new OracleParameter("pStart", OracleDbType.Date) { Value = startDate.Value.Date });

        if (endDate.HasValue)
        {
            var inclusiveEnd = endDate.Value.Date.AddDays(1).AddSeconds(-1);
            cmd.Parameters.Add(new OracleParameter("pEnd", OracleDbType.Date) { Value = inclusiveEnd });
        }
    }


    public IActionResult OnGetTablesState()
    {
        var connString = _config.GetConnectionString("OracleConnection");
        using var conn = new OracleConnection(connString);
        conn.Open();

        var list = new List<object>();
        foreach (var table in AllowedTables)
        {
            try
            {
                var cols = GetColumns(conn, table, DefaultExcludeColumns);
                var hasPart = cols.Any(c => string.Equals(c, "N_PART", StringComparison.OrdinalIgnoreCase));
                var hasPlaw = cols.Any(c => string.Equals(c, "N_PLAW", StringComparison.OrdinalIgnoreCase));

                bool hasData = false;
                using (var cmd = new OracleCommand($"SELECT 1 FROM {table} FETCH FIRST 1 ROWS ONLY", conn))
                using (var r = cmd.ExecuteReader())
                    hasData = r.Read();

                list.Add(new { table, hasData, hasPart, hasPlaw });
            }
            catch
            {
                // Если таблица недоступна/ошибка - считаем, что данных нет
                list.Add(new { table, hasData = false, hasPart = false, hasPlaw = false });
            }
        }
        return new JsonResult(list, new JsonSerializerOptions { PropertyNamingPolicy = null });
    }



    private static DateTime? ParseDate(string? s)
    {
        if (string.IsNullOrWhiteSpace(s)) return null;

        var formats = new[] { "yyyy-MM-dd", "dd.MM.yyyy", "dd.MM.yy" };
        if (DateTime.TryParseExact(s.Trim(), formats, CultureInfo.InvariantCulture,
            DateTimeStyles.AssumeLocal, out var dt))
            return dt.Date;

        if (DateTime.TryParse(s, out dt)) return dt.Date;
        return null;
    }

    private static List<string> GetColumns(OracleConnection conn, string tableUpper, HashSet<string> exclude)
    {
        var sql = $"SELECT * FROM {tableUpper} FETCH FIRST 1 ROWS ONLY";
        using var cmd = new OracleCommand(sql, conn);
        using var reader = cmd.ExecuteReader(CommandBehavior.SchemaOnly);

        var schemaTable = reader.GetSchemaTable();
        var cols = new List<string>();

        if (schemaTable != null)
        {
            foreach (DataRow row in schemaTable.Rows)
            {
                var name = row["ColumnName"]?.ToString();
                if (!string.IsNullOrWhiteSpace(name) && !exclude.Contains(name))
                    cols.Add(name);
            }
        }

        if (cols.Count == 0)
            throw new InvalidOperationException($"Не удалось получить колонки таблицы {tableUpper}.");

        return cols;
    }

    private static DataTable ToDataTable(OracleDataReader reader)
    {
        var dt = new DataTable();
        var schema = reader.GetColumnSchema();

        foreach (var col in schema)
        {
            var type = col.DataType ?? typeof(string);
            if (type == typeof(object) && !string.IsNullOrEmpty(col.DataTypeName))
            {
                var name = col.DataTypeName.ToUpperInvariant();
                if (name.Contains("DATE") || name.Contains("TIMESTAMP"))
                    type = typeof(DateTime);
                else if (name.Contains("NUMBER"))
                    type = typeof(decimal);
                else if (name.Contains("FLOAT") || name.Contains("BINARY_FLOAT") || name.Contains("BINARY_DOUBLE"))
                    type = typeof(double);
            }

            dt.Columns.Add(col.ColumnName, type);
        }

        while (reader.Read())
        {
            var row = dt.NewRow();
            for (int i = 0; i < dt.Columns.Count; i++)
                row[i] = reader.IsDBNull(i) ? DBNull.Value : reader.GetValue(i);

            dt.Rows.Add(row);
        }

        return dt;
    }




    public IActionResult OnGetRunSql(string sql)
    {
        if (string.IsNullOrWhiteSpace(sql))
            return new JsonResult(new { error = "SQL-запрос обязателен." }) { StatusCode = 400 };

        if (!sql.Trim().StartsWith("SELECT", StringComparison.OrdinalIgnoreCase))
            return new JsonResult(new { error = "Разрешены только SELECT-запросы." }) { StatusCode = 400 };

        // Проверка: таблица из запроса должна быть выбрана
        var selectedTable = HttpContext.Request.Query["currentTable"].ToString(); // передаем из JS
        if (string.IsNullOrWhiteSpace(selectedTable))
            return new JsonResult(new { error = "Сначала выберите таблицу слева." }) { StatusCode = 400 };

        // Извлекаем имена таблиц из SQL (простая проверка)
        var tablesInSql = ExtractTablesFromSql(sql);
        if (tablesInSql.Any(t => !string.Equals(t, selectedTable, StringComparison.OrdinalIgnoreCase)))
            return new JsonResult(new { error = "Запрос содержит таблицы, которые не выбраны." }) { StatusCode = 400 };

        // Проверка на AllowedTables
        if (!AllowedTables.Contains(selectedTable.ToUpperInvariant()))
            return new JsonResult(new { error = "Таблица не разрешена." }) { StatusCode = 400 };

        // Выполнение запроса
        var connString = _config.GetConnectionString("OracleConnection");
        using var conn = new OracleConnection(connString);
        conn.Open();

        using var cmd = new OracleCommand(sql, conn);
        using var reader = cmd.ExecuteReader();

        var rows = new List<Dictionary<string, object?>>();
        var schema = reader.GetColumnSchema();

        while (reader.Read())
        {
            var row = new Dictionary<string, object?>(StringComparer.OrdinalIgnoreCase);
            foreach (var col in schema)
            {
                var raw = reader[col.ColumnName];
                if (raw == DBNull.Value)
                    row[col.ColumnName] = null;
                else if (raw is DateTime dt)
                    row[col.ColumnName] = dt.ToString("dd.MM.yyyy");
                else
                    row[col.ColumnName] = raw;
            }
            rows.Add(row);
        }

        return new JsonResult(rows);
    }

    private static List<string> ExtractTablesFromSql(string sql)
    {
        var result = new List<string>();
        var tokens = sql.Split(new[] { ' ', '\n', '\r', '\t' }, StringSplitOptions.RemoveEmptyEntries);
        for (int i = 0; i < tokens.Length; i++)
        {
            if (tokens[i].Equals("FROM", StringComparison.OrdinalIgnoreCase) && i + 1 < tokens.Length)
            {
                result.Add(tokens[i + 1].Trim(',', ';'));
            }
            if (tokens[i].Equals("JOIN", StringComparison.OrdinalIgnoreCase) && i + 1 < tokens.Length)
            {
                result.Add(tokens[i + 1].Trim(',', ';'));
            }
        }
        return result;
    }



    public IActionResult OnGetExportSql(string sql)
    {
        if (string.IsNullOrWhiteSpace(sql))
            return BadRequest("SQL-запрос обязателен.");

        if (!sql.Trim().StartsWith("SELECT", StringComparison.OrdinalIgnoreCase))
            return BadRequest("Разрешены только SELECT-запросы.");

        var connString = _config.GetConnectionString("OracleConnection");
        using var conn = new OracleConnection(connString);
        conn.Open();

        using var cmd = new OracleCommand(sql, conn);
        using var reader = cmd.ExecuteReader();
        var dt = ToDataTable(reader);

        using var wb = new XLWorkbook();
        var ws = wb.Worksheets.Add(dt, "SQL_Result");

        var tbl = ws.Tables.FirstOrDefault();
        if (tbl != null)
        {
            tbl.ShowAutoFilter = true;
        }
        ws.SheetView.FreezeRows(1);
        ApplyDateColumnFormats(ws, dt);
        ws.Columns().AdjustToContents();

        byte[] bytes;
        using (var ms = new MemoryStream())
        {
            wb.SaveAs(ms);
            bytes = ms.ToArray();
        }

        var fileName = $"SQL_{DateTime.Now:ddMMyy}.xlsx";
        return File(bytes, ContentTypeXlsx, fileName);
    }


    private static void ApplyDateColumnFormats(IXLWorksheet ws, DataTable dt)
    {
        for (int i = 0; i < dt.Columns.Count; i++)
        {
            var col = dt.Columns[i];
            if (col.DataType == typeof(DateTime))
                ws.Column(i + 1).Style.DateFormat.Format = "dd.MM.yy";
        }
    }

}
